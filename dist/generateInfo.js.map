{"version":3,"sources":["generateInfo.ts"],"names":["configObject","promises_1","require","path","parser_enum_1","read_local_file_1","generateInfo","userInput","details","buildObject","writeFile","JSON","stringify","_a","sent","basicGeneratedInfo","generatedInfo","getCollections","loader","collections","__assign","readLocalJSONFile","packageJsonFile","time","Date","toISOString","cloudcannon","name","version","collectionsConfig","keys","Object","result","key","files","readdir","join","_b","map","file","filePath","fileType","extname","loaderType","getLoaderType","collection","ext","console","log","e_1","keys_1","_i","length","matchFileType","substring","ParsersEnum","parse","exports"],"mappings":"urDAAA,IASIA,aATJC,WAAAC,QAAA,eACAC,KAAAD,QAAA,QACAE,cAAAF,QAAA,sBAGAG,kBAAAH,QAAA,4BAMA,SAAsBI,aAAaC,G,gHAG/B,OADMC,EAAUC,YAAYF,GAC5B,CAAA,EAAMN,WAAAS,UAAU,2BAA4BC,KAAKC,UAAUJ,EAAS,KAAM,K,cAA1EK,EAAAC,O,SAIJ,SAAeL,YAAYF,G,gHAKH,MAAA,CAAA,EAAMQ,sB,OAER,OAFdC,EAAgBH,EAAAC,OAEF,CAAA,EAAMG,eAAeV,EAAUW,OAAQX,EAAUY,c,OAEnE,OAFkBN,EAAAC,OAElB,CAAA,EADAd,aAAYoB,SAAAA,SAAA,GAAOb,GAAcS,SAKrC,SAAeD,qB,gHACa,MAAA,CAAA,EAAMV,kBAAAgB,kBAAkB,oB,OAEhD,OAFMC,EAAkBT,EAAAC,OAExB,CAAA,EAAO,CACHS,MAAM,IAAIC,MAAOC,cACjBC,YAAa,CACTC,KAAML,EAAgBK,KACtBC,QAASN,EAAgBM,gBAKrC,SAAeX,eAAeC,EAAkBW,G,YAAA,IAAAA,IAAAA,EAAA,I,+GACtCC,EAAOC,OAAOD,KAAKD,GAEnBG,EAAuB,G,WAChBC,G,iEACDC,OAAK,E,iBAEG,O,sBAAA,CAAA,EAAMjC,WAAAkC,QAAQhC,KAAKiC,KAAK,IAAKP,EAAkBI,GAAK9B,Q,cAA5D+B,EAAQG,EAAAvB,OACRkB,EAAOC,GAAOC,EAAMI,IAAI,SAACC,GAErB,IAAMC,EAAWrC,KAAKiC,KAAK,IAAKP,EAAkBI,GAAK9B,KAAMoC,GACvDE,EAAWtC,KAAKuC,QAAQF,GACxBG,EAAaC,cAAcH,EAAUvB,GAE3C,MAAO,CACHf,KAAMqC,EACNK,WAAYZ,EACZa,IAAKL,EACLvB,OAAQyB,K,+BAIhBI,QAAQC,IAAI,QAASC,G,+BAlBbC,EAAApB,E,wBAAAqB,EAAAD,EAAAE,QAAPnB,EAAGiB,EAAAC,G,KAAHlB,KAAW,CAAA,EAAA,G,wCAAJkB,I,aAqBhB,MAAA,CAAA,EAAOnB,QAGX,SAASY,cAAcH,EAAkBvB,GAEjCmC,EAAgBZ,EAASa,UAAU,GAEpCpC,GACC6B,QAAQC,IAAI5C,cAAAmD,YAAYC,MAAMtC,EAAOmC,KAjEjDI,QAAAnD,aAAAA","file":"generateInfo.js","sourcesContent":["import { writeFile, readdir } from 'fs/promises';\nimport * as path from 'path';\nimport { ParsersEnum } from './enum/parser.enum'\nimport { IUserInfo, ILoader } from './interfaces/user-info.interface';\nimport { IInfo, IGeneratedInfo } from './interfaces/info.interface'\nimport { readLocalJSONFile } from './helper/read-local-file';\nimport { ICollections } from './interfaces/collections.interface'\nimport { match } from 'assert/strict';\n\nlet configObject: IInfo;\n\nexport async function generateInfo(userInput: IUserInfo): Promise<void> {\n\n    const details = buildObject(userInput);\n    await writeFile('./_cloudcannon/info.json', JSON.stringify(details, null, 2));\n\n}\n\nasync function buildObject(userInput: IUserInfo): Promise<IInfo> {\n    // TODO: Validate the userInput object is correct\n\n    // TODO: Generate the collections from the collections into collections config\n\n    let generatedInfo = await basicGeneratedInfo();\n\n    let collections = await getCollections(userInput.loader, userInput.collections);\n    configObject = {...userInput, ...generatedInfo}\n    return configObject;\n}\n\n\nasync function basicGeneratedInfo(): Promise<IGeneratedInfo> {\n    const packageJsonFile = await readLocalJSONFile('../package.json');\n\n    return {\n        time: new Date().toISOString(),\n        cloudcannon: {\n            name: packageJsonFile.name,\n            version: packageJsonFile.version\n        }\n    }\n}\n\nasync function getCollections(loader?: ILoader, collectionsConfig: any = {} ): Promise<any> {\n    const keys = Object.keys(collectionsConfig);\n\n    const result: ICollections = {};\n        for (let key of keys) {\n            let files;\n            try {\n                files = await readdir(path.join('.', collectionsConfig[key].path));\n                result[key] = files.map((file) => {\n\n                    const filePath = path.join('.', collectionsConfig[key].path, file);\n                    const fileType = path.extname(filePath);\n                    const loaderType = getLoaderType(fileType, loader);\n\n                    return {\n                        path: filePath,\n                        collection: key,\n                        ext: fileType,\n                        loader: loaderType\n                    };\n                });\n            } catch (e) {\n                console.log(\"error\", e);\n            }\n        }\n        return result;\n    }\n\n    function getLoaderType(fileType: string, loader?: ILoader): any {\n\n        let matchFileType = fileType.substring(1);\n\n        if(loader) {\n            console.log(ParsersEnum.parse(loader[matchFileType]))\n        }\n        // ParsersEnum.parse(loader)\n        // return \"Hello\"\n        // // return loader ? loader[matchFileType] : Object.values(Parsers)[Object.keys(Parsers).indexOf(matchFileType);\n    }\n"]}